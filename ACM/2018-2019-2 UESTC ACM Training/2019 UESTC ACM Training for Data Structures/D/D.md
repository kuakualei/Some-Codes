# D题

题目所求为字典序最大的子序列。这道题有一个特点：  
对于字符串 f1234f123，只要后面的字符串够用，取 ff 就是很好的。即第二个f的优先级高于前面的所有字符。  
如果只有一个 f，那么后面 e 就是很好的。即在后面有足够多字符串的时候，取完所有 f，再取完所有 e，再取完所有 d……  
诶好像有点像单调队列诶。但是样例输出并不是单调队列额。  
是因为后面的数不够用了，不能直接去掉前面的某些数而给我后面的大哥(指f等)让位。

所以就用单调栈啦。实现单调栈的时候， push_back(ch) 前要把所有小于 ch 的字符全部 pop 出来。但是这里得看后面的数够不够用，就是一个判断的事情。

至于字典序，因为题目设计的 16 种字符的顺序正好和 ASCII 大小顺序相同，所以直接用字符比大小就行了。

代码如下：  
没有拿链表或者 stack 实现，直接手写其实也不麻烦。

```c++
    while (cin >> n >> k)
    {
        if (k == 0)
        {
            for (int i = 0; i < n; i++)
                cin >> temp;
            cout << endl;
            continue;
        }
```

核心代码不到十行诶

```c++
        leng = 0;
        for (int i = 0; i < n; i++)
        {
            cin >> temp;
            while (leng > 0 && ans[leng - 1] < temp && k - leng + 1 <= n - i)
            //栈里还有数，并且比 temp 小，后面还有足够的数，就可以把栈顶的数拿出来
                leng--;
            ans[leng++] = temp;//入栈
        }
```

输出。

```c++
        for (int i = 0; i < leng; i++)
            cout << ans[i];
        cout << "\n";
    }
```

输出这一步，其实也可以用字符串输出：

```c++
ans[leng]='\0';
cout << ans;
```

两种版本在 Lutece 上提交的时间空间占用：

代码版本|时间|空间|
---|----|----|
一次输出整个字符串|45ms|3152KB|
for 循环输出每个字符|57ms|3048KB|

可以看出输出字符串，时间占用会更小，但是空间会略大（大概给常字符串分配了空间）。
