# D题

很明显是两个 LIS，但是这两个 LIS 怎么组合好呢？想一想用 lower_bound() 的 LIS 解题过程：  
> 建一个单调数组 a[i]，存长度为 i 的 LIS 的最后一个数的最小取值，在 a[i] 中搜索新的数，然后把新的数替换进去，即这个数在 LIS 数组中可以排第 lower_bound 位。

即这个数在 LIS 数组中可以排第 lower_bound 位。

好了，把原数组中每个数的 lower_bound 值存起来。就得到了以它为终点的 LIS 最大长度。接下来怎么办呢？

我们注意到，如果把某一个点定为 oy 序列的最大值，它的最长 oy 序列的长度是 2*`以他为终点的两边的 LIS 的长度的较小值`-1。  
所以，算完前面的以某数为终点的 LIS 最大长度以后，再反向算一遍，再 O(n) 扫一遍“以某点为终点的两个 LIS 长度的较小值”的最大值。然后把结果乘 2 减 1。

顺便， LIS 有个易混点，即注意 lower_bound 和 upper_bound 的选择：upper_bound 是不下降子序列，lower_bound 是上升子序列。  
因为上升子序列的 lis 里面一个数不能排在相同的数的后面，所以这个数必须要找到 lower_bound()。
