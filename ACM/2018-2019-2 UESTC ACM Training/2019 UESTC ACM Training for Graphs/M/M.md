# M题

看到这题，感觉就是拓扑排序的板题，然后把他们的排序的值算一下加起来就完了。

然后赶紧搜了一个“拓扑排序 C++”，简单看了一下思想以后，开始写，然后就交了。

拓扑排序大概的过程：

1. （输入边的时候）计算每边的入度
2. 扫一遍点，把入度为 0 的点装进堆栈（~~队列和堆栈都可以吧~~）
3. while 堆栈不空：从堆栈里拿一个点出来，把点装进拓扑排序的集合，并删掉它的所有边。删边的过程中度数--。如果产生了入度为 0的点，把这个点装进堆栈

如果存在拓扑排序，所有点都在集合里，同时所有点的度都为 0；反之，度不为 0 的点构成了环。
对于这个题，有环即无解。在每一个删边的时候，让终点取 `起点权值+1` 和`终点当前值`的较大者（保证尽量小），最后把所有点的权重加起来就好了。

然后 WA1。？？？不好意思看错题了，没看到 o = 3 的情况。~~都怪样例没有o = 3，对于我们这种先看样例输入输出再看题的人很不友好~~

所以怎么改呢？emm 一定要保持这些点相等额。诶其实可以搞一个并查集，表示他们一定相等，然后把题中的大于/小于条件中的所有点改成他们的祖先，然后来搞，最后算权重和的时候每个点算成祖先的。

然后就可以了~~虽然因为用`a[maxm]`写成`a[maxn]`导致RE了好几次~~

## 又解：差分约束原理

* `a>=b+1`: 建立从 b 到 a 的权值为 1 的边；
* `a==b`: 建立 a, b 权值为 0 的双向边；
* 再建立 0 到所有点的权值为 0 的边；dis[0] = 1

然后 SPFA 跑最大路径。

判断无解：有正环：SPFA中，如果某点入队列次数达到某个阈值的时候认为存在正环；在稀疏图中，阈值一般取 n/2。
